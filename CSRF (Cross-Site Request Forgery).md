*   **Tools:** Using Burp Suite Pro will be better.
*   **Concept:** CSRF is all about changing the email/state of the user using a link. Once the link is opened, the email is changed to what was forged (also applies to passwords).
*   **Mitigation:**
    *   "Current password" requirement is a solution because it validates the current user before entering the new password.
    *   Servers use **CSRF tokens** that validate the request. These are generated in the back-end using timestamps, user cookies, or randomly generated, but they must be one-time use or tied to the user ID.

## How developers try to stop CSRF:

1.  **CSRF Tokens:** Developers make a hidden parameter called csrf tokens where it has a unique value for each user and is randomly generated by the server.
    *   *Bypass:* We try to break this by intercepting the request to get the csrf token and change or copy it to try and access the account ourselves.
2.  **SameSite Cookies:** Used by most browsers by configuring cookies to `strict` or `lax`.
    *   **Strict:** The client browser won't send the cookies during cross-site requests.
    *   **Lax:** Tells the client browser to send cookies only in requests when the user clicks a link to navigate to the site.
3.  **Referrer Header:** Developers also use referrer headers to filter the server requests that are not from the original website.
    *   *Bypass:* However, it can be bypassed by changing it to `localhost` or the original website URL.

## Scenarios:

1.  The current password can be deleted in the request; if the server doesn't validate it, we can change the password without the current password.
2.  Changing the request method (e.g., POST to GET) is a way of delivering a CSRF.
3.  If the session is invalid for the use, we can use another and change its value in the request (session fixation/swapping).
4.  The token may be one-time use only. By refreshing the session we will get a new token, but make sure to drop the refreshed session to not use the new token, and then change the old token with the new one to change the password/email.
5.  **CRLF Injection:** Sometimes we need to chain a CRLF by using an injection for the cookies to inject headers in the request as we want.
6.  If the website allows state-changing requests with the **GET** HTTP request.
7.  Some websites require third-party sites to send authenticated requests. In this case, we can change the `SameSite` parameter to `None`, allowing sending cookies of the users to implement the CSRF.
8.  Any user who is not using a browser that implements a SameSite policy is vulnerable to CSRF.

## How to Hunt for CSRF:

1.  Visit the target site and start searching for any **state-changing events** that include changing passwords, emails, usernames, or permissions. Collect all of them in a list.
2.  Go through each link using Burp Suite, checking if there is any CSRF protection, and use the search to find any CSRF keywords.
3.  To confirm our finding, make a script that we are going to execute ourselves.

**Example Exploit Script:**
```html
<html>
  <form method="post" action="target_infected_url" id="csrf-form">
    <input type="text" name="new-password" value="u have been hacked">
    <input type="submit" value="submit">
  </form>
  <script>
    document.getElementById("csrf-form").submit();
  </script>
</html>```

